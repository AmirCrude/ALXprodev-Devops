#!/bin/bash

# Task 5: Parallel Data Fetching
# Fetch data for Pokémon in parallel using background jobs

# List of Pokémon to fetch
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")

# Directory to store Pokémon data
DATA_DIR="pokemon_data"

# Base API URL
BASE_URL="https://pokeapi.co/api/v2/pokemon"

# Maximum concurrent jobs
MAX_JOBS=3

# Create data directory
mkdir -p "$DATA_DIR"

echo "Starting parallel Pokémon data fetching..."
echo "Maximum concurrent jobs: $MAX_JOBS"
echo "============================================="

# Array to store job PIDs
declare -a JOB_PIDS

# Function to fetch a single Pokémon
fetch_pokemon_job() {
    local pokemon="$1"
    local output_file="${DATA_DIR}/${pokemon}.json"
    
    echo "Job for $pokemon started (PID: $$)..."
    
    # Make API request
    if curl -s -f --max-time 30 "${BASE_URL}/${pokemon}" -o "$output_file" 2>/dev/null; then
        # Validate JSON
        if ./bin/jq.exe -e . >/dev/null 2>/dev/null < "$output_file"; then
            echo "Job for $pokemon completed successfully ✓"
            return 0
        else
            echo "Job for $pokemon failed: Invalid JSON ✗"
            rm -f "$output_file"
            return 1
        fi
    else
        echo "Job for $pokemon failed: Network error ✗"
        rm -f "$output_file"
        return 1
    fi
}

# Function to wait for job slots
wait_for_job_slot() {
    while true; do
        # Count active jobs
        local active_jobs=0
        for job_pid in "${JOB_PIDS[@]}"; do
            if kill -0 "$job_pid" 2>/dev/null; then
                ((active_jobs++))
            fi
        done
        
        # If we have room for more jobs, break
        if [ $active_jobs -lt $MAX_JOBS ]; then
            break
        fi
        
        # Wait a bit before checking again
        sleep 0.5
    done
}

# Function to clean completed jobs
clean_completed_jobs() {
    local i=0
    while [ $i -lt ${#JOB_PIDS[@]} ]; do
        local job_pid=${JOB_PIDS[$i]}
        
        # Check if job is still running
        if ! kill -0 "$job_pid" 2>/dev/null; then
            # Job completed, wait for it to get exit status
            wait "$job_pid" 2>/dev/null
            # Remove from array
            unset JOB_PIDS[$i]
            JOB_PIDS=("${JOB_PIDS[@]}")
        else
            ((i++))
        fi
    done
}

# Launch Pokémon fetch jobs
for pokemon in "${POKEMON_LIST[@]}"; do
    # Wait for available job slot
    if [ ${#JOB_PIDS[@]} -ge $MAX_JOBS ]; then
        echo "Maximum jobs reached ($MAX_JOBS). Waiting for job completion..."
        wait_for_job_slot
        clean_completed_jobs
    fi
    
    echo "Launching job for: $pokemon"
    
    # Start job in background
    fetch_pokemon_job "$pokemon" &
    
    # Store job PID
    JOB_PID=$!
    JOB_PIDS+=($JOB_PID)
    
    echo "  Job started with PID: $JOB_PID"
    
    # Small delay between job starts
    sleep 0.2
done

echo ""
echo "All jobs launched. Waiting for all jobs to complete..."
echo ""

# Wait for all jobs to finish
while [ ${#JOB_PIDS[@]} -gt 0 ]; do
    # Clean completed jobs
    clean_completed_jobs
    
    # Show current job status
    if [ ${#JOB_PIDS[@]} -gt 0 ]; then
        echo -n "Active jobs (PIDs): "
        for job_pid in "${JOB_PIDS[@]}"; do
            echo -n "$job_pid "
        done
        echo "- waiting..."
        sleep 1
    fi
done

echo ""
echo "============================================="
echo "All jobs completed!"
echo ""

# Count results
SUCCESS_COUNT=0
FAIL_COUNT=0

for pokemon in "${POKEMON_LIST[@]}"; do
    if [ -f "${DATA_DIR}/${pokemon}.json" ]; then
        ((SUCCESS_COUNT++))
    else
        ((FAIL_COUNT++))
    fi
done

echo "Job results summary:"
echo "Successful jobs: $SUCCESS_COUNT"
echo "Failed jobs: $FAIL_COUNT"
echo ""

echo "Files created in $DATA_DIR/:"
ls -la "$DATA_DIR/" 2>/dev/null || echo "  (no files created)"

if [ $FAIL_COUNT -gt 0 ]; then
    exit 1
else
    exit 0
fi